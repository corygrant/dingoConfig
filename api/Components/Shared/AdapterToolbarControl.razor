@using contracts.Adapters
@inject HttpClient Http
@inject ISnackbar Snackbar
@rendermode InteractiveServer
@implements IDisposable

<MudBadge Color="Color.Warning"
          Dot="true"
          Overlap="true"
          Bordered="true"
          Visible="@(_available?.Ports?.Length == 0)">
    <MudChip T="string"
             Icon="@Icons.Material.Filled.Cable"
             Color="@GetAdapterChipColor()"
             Variant="Variant.Filled"
             Size="Size.Medium"
             OnClick="@((e) => TogglePopover(e))"
             Style="cursor: pointer;">
        @GetAdapterText()
    </MudChip>
</MudBadge>

<MudPopover Open="@_isOpen"
            AnchorOrigin="Origin.BottomRight"
            TransformOrigin="Origin.TopRight"
            OverflowBehavior="OverflowBehavior.FlipAlways">
    <MudPaper Class="pa-4" Style="min-width: 400px;" Elevation="8">
        @if (_loading)
        {
            <MudProgressCircular Indeterminate="true" Size="Size.Small" />
        }
        else
        {
            <MudText Typo="Typo.h6" Class="mb-3">
                <MudIcon Icon="@Icons.Material.Filled.Cable" Class="mr-2" />
                Adapter
            </MudText>

            @if (_status?.IsConnected == true)
            {
                <!-- Connected State -->
                <MudAlert Severity="Severity.Success" Class="mb-3" Dense="true">
                    <strong>Connected</strong>
                </MudAlert>

                <MudText Typo="Typo.body2" Class="mb-1"><strong>Adapter:</strong> @_status.ActiveAdapter</MudText>
                <MudText Typo="Typo.body2" Class="mb-3"><strong>Port:</strong> @_status.ActivePort</MudText>

                <MudButton Variant="Variant.Filled"
                           Color="Color.Error"
                           StartIcon="@Icons.Material.Filled.LinkOff"
                           OnClick="@DisconnectAdapter"
                           Disabled="@_disconnecting"
                           FullWidth="true">
                    @(_disconnecting ? "Disconnecting..." : "Disconnect")
                </MudButton>
            }
            else
            {
                <!-- Disconnected State -->
                <MudAlert Severity="Severity.Warning" Class="mb-3" Dense="true">
                    <strong>Not Connected</strong>
                </MudAlert>

                <MudSelect @bind-Value="_selectedAdapterType"
                           Label="Adapter Type"
                           Variant="Variant.Outlined"
                           Dense="true"
                           Class="mb-2"
                           T="string">
                    @if (_available?.Adapters != null)
                    {
                        @foreach (var adapter in _available.Adapters)
                        {
                            <MudSelectItem T="string" Value="@adapter">@adapter</MudSelectItem>
                        }
                    }
                </MudSelect>

                @* Show port selector for USB and SLCAN only (not PCAN or Sim) *@
                @if (!string.IsNullOrEmpty(_selectedAdapterType) && _selectedAdapterType != "Sim" && _selectedAdapterType != "PCAN")
                {
                    <MudSelect @bind-Value="_selectedPort"
                               Label="Port"
                               Variant="Variant.Outlined"
                               Dense="true"
                               Class="mb-2"
                               T="string">
                        @if (_available?.Ports != null)
                        {
                            @foreach (var port in _available.Ports)
                            {
                                <MudSelectItem T="string" Value="@port">@port</MudSelectItem>
                            }
                        }
                    </MudSelect>
                }

                @* Show bitrate selector for SLCAN and PCAN (not USB or Sim) *@
                @if (!string.IsNullOrEmpty(_selectedAdapterType) && _selectedAdapterType != "USB" && _selectedAdapterType != "Sim")
                {
                    <MudSelect @bind-Value="_selectedBitrate"
                               Label="Bitrate"
                               Variant="Variant.Outlined"
                               Dense="true"
                               Class="mb-3"
                               T="string">
                        <MudSelectItem T="string" Value="@("1000K")">1000K</MudSelectItem>
                        <MudSelectItem T="string" Value="@("500K")">500K</MudSelectItem>
                        <MudSelectItem T="string" Value="@("250K")">250K</MudSelectItem>
                        <MudSelectItem T="string" Value="@("125K")">125K</MudSelectItem>
                    </MudSelect>
                }
                else
                {
                    @* Add spacing if bitrate is hidden *@
                    <div class="mb-3"></div>
                }

                @if (_available?.Adapters?.Length == 0 || _available?.Ports?.Length == 0)
                {
                    <MudAlert Severity="Severity.Warning" Class="mb-3" Dense="true">
                        @if (_available?.Adapters?.Length == 0)
                        {
                            <MudText Typo="Typo.caption">No adapters available</MudText>
                        }
                        @if (_available?.Ports?.Length == 0)
                        {
                            <MudText Typo="Typo.caption">No ports detected</MudText>
                        }
                    </MudAlert>
                }

                <MudStack Row="true" Spacing="2">
                    <MudButton Variant="Variant.Filled"
                               Color="Color.Primary"
                               StartIcon="@Icons.Material.Filled.Link"
                               OnClick="@ConnectAdapter"
                               Disabled="@(!CanConnect())"
                               FullWidth="true">
                        @(_connecting ? "Connecting..." : "Connect")
                    </MudButton>
                    <MudIconButton Icon="@Icons.Material.Filled.Refresh"
                                   OnClick="@RefreshAvailable"
                                   Color="Color.Default"
                                   Size="Size.Medium" />
                </MudStack>
            }
        }
    </MudPaper>
</MudPopover>

@code {
    private bool _isOpen;
    private AdapterStatusResponse? _status;
    private AdapterAvailableResponse? _available;
    private bool _loading = true;
    private bool _connecting = false;
    private bool _disconnecting = false;
    private System.Threading.Timer? _refreshTimer;

    private string _selectedAdapterType = string.Empty;
    private string _selectedPort = string.Empty;
    private string _selectedBitrate = "500K";

    protected override async Task OnInitializedAsync()
    {
        await LoadData();

        // Refresh status every second
        _refreshTimer = new System.Threading.Timer(async _ =>
        {
            await InvokeAsync(async () =>
            {
                await LoadData();
                StateHasChanged();
            });
        }, null, TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1));
    }

    private void TogglePopover(MouseEventArgs e)
    {
        _isOpen = !_isOpen;
    }

    private async Task LoadData()
    {
        _loading = true;
        try
        {
            var statusTask = Http.GetFromJsonAsync<AdapterStatusResponse>("api/adapter/status");
            var availableTask = Http.GetFromJsonAsync<AdapterAvailableResponse>("api/adapter/available");

            await Task.WhenAll(statusTask, availableTask);

            _status = statusTask.Result;
            _available = availableTask.Result;

            if (_status?.IsConnected != true && _available != null)
            {
                if (string.IsNullOrEmpty(_selectedAdapterType) && _available.Adapters?.Length > 0)
                {
                    _selectedAdapterType = _available.Adapters[0];
                }
                if (string.IsNullOrEmpty(_selectedPort) && _available.Ports?.Length > 0)
                {
                    _selectedPort = _available.Ports[0];
                }
            }
        }
        catch
        {
            // Silently fail
        }
        finally
        {
            _loading = false;
        }
    }

    private async Task RefreshAvailable()
    {
        try
        {
            _available = await Http.GetFromJsonAsync<AdapterAvailableResponse>("api/adapter/available");
            Snackbar.Add("Adapter list refreshed", Severity.Info);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error refreshing adapters: {ex.Message}", Severity.Error);
        }
    }

    private async Task ConnectAdapter()
    {
        _connecting = true;
        try
        {
            // Set port based on adapter type
            string port = _selectedAdapterType switch
            {
                "Sim" => "Simulated",
                "PCAN" => "PCAN_USBBUS1", // Default PCAN port
                _ => _selectedPort
            };

            // Set bitrate based on adapter type
            var bitrate = _selectedAdapterType is "Sim" or "USB"
                ? "1000K"
                : _selectedBitrate;

            var request = new ConnectAdapterRequest
            {
                AdapterType = _selectedAdapterType,
                Port = port,
                Bitrate = bitrate
            };

            var response = await Http.PostAsJsonAsync("api/adapter/connect", request);

            if (response.IsSuccessStatusCode)
            {
                Snackbar.Add($"Connected to {_selectedAdapterType}", Severity.Success);
                await LoadData();
                _isOpen = false; // Close popover on success
            }
            else
            {
                var error = await response.Content.ReadAsStringAsync();
                Snackbar.Add($"Failed to connect: {error}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error connecting: {ex.Message}", Severity.Error);
        }
        finally
        {
            _connecting = false;
        }
    }

    private async Task DisconnectAdapter()
    {
        _disconnecting = true;
        try
        {
            var response = await Http.PostAsync("api/adapter/disconnect", null);

            if (response.IsSuccessStatusCode)
            {
                Snackbar.Add("Disconnected from adapter", Severity.Success);
                await LoadData();
                _isOpen = false; // Close popover on success
            }
            else
            {
                var error = await response.Content.ReadAsStringAsync();
                Snackbar.Add($"Failed to disconnect: {error}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error disconnecting: {ex.Message}", Severity.Error);
        }
        finally
        {
            _disconnecting = false;
        }
    }

    private bool CanConnect()
    {
        if (_connecting || string.IsNullOrWhiteSpace(_selectedAdapterType))
            return false;

        // Sim adapter doesn't need port or bitrate
        if (_selectedAdapterType == "Sim")
            return true;

        // USB adapter needs port but not bitrate
        if (_selectedAdapterType == "USB")
            return !string.IsNullOrWhiteSpace(_selectedPort);

        // PCAN needs bitrate but not port
        if (_selectedAdapterType == "PCAN")
            return !string.IsNullOrWhiteSpace(_selectedBitrate);

        // SLCAN needs both port and bitrate
        return !string.IsNullOrWhiteSpace(_selectedPort) && !string.IsNullOrWhiteSpace(_selectedBitrate);
    }

    private Color GetAdapterChipColor()
    {
        if (_status?.IsConnected == true)
        {
            return Color.Success; // Green when connected
        }
        return Color.Default; // Gray when disconnected
    }

    private string GetAdapterText()
    {
        if (_status?.IsConnected == true)
        {
            return $"Adapter: {_status.ActiveAdapter}";
        }
        return "Adapter: Disconnected";
    }

    public void Dispose()
    {
        _refreshTimer?.Dispose();
    }
}
